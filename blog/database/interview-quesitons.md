整理数据库八股文。

## ACID

- 原子性 (Atomicity) ：一个事务包含若干操作，要么全做，要么全不做；如果失败，需要 rollback 操作。
- 一致性 (Consistency) ：一个事务执行之前和执行之后，数据必须保持一致性。
  - 例如，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。
- 隔离性 (Isolation) ：多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
  - 事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- 持久性 (Durability) ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



## 数据库设计范式

- 1NF：无重复的列（列的原子性）
- 2NF：属性完全依赖于主键
  - 例子：有一个表 `<订单编号，房间号，联系人，联系人电话，联系人身份号>`，如果一个人订了多个房间，那么这个表里就会重复记录 `<联系人，联系人电话，联系人身份证>` 这些信息，因此需要表拆分 `<订单编号，房间号，联系人身份证号>` 和 `<联系人身份证，联系人，联系人电话>`。
- 3NF：每一列数据都和主键直接相关，而不能间接相关
  - 例子：假设有一个学生信息表 `<学号，姓名，年龄，性别，所在院校，院校地址，院校电话>`，存在这样的依赖 `学号 -> 所在院校 -> (院校地址，院校电话)` ，**如果有好多个统一学院的学生在这个表，那么 `<院校地址，院校电话>` 就会重复记录**，因此需要拆分为 `<学号，姓名，年龄，性别，所在院校>` 和 `<所在院校，院校地址，院校电话>` 。



## 事务隔离

首先，明确在事务并发的场景下，会出现的问题：

- 脏读：脏读发生在一个事务 A 读取了被另一个事务 B 修改，但是还未提交的数据。假如 B 回退，则事务 A 读取的是无效的数据。
- 不可重复读：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了（被另外一个事务 update 并且 commit 了）。
- 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据（与不可重复读类似）。
- 丢失更新：一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据不一致。

区分不可重复读与脏读：

- 脏读是在当前事务内读取到未 commit 的数据
- 不可重复读是在当前事务内读取到已提交的数据，但前后不一致。



事务隔离的类型，要求由低到高依次为：

- 读未提交 Read Uncommitted：一个事务可以读取另一个事务并未提交的更新结果。
- 读已提交 Read Committed：大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一数据更新后的结果。
- 可重复读 Repeatable Read：MySQL 的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。
- 串行化 Serializable：最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。

4 种事务隔离可能出现的问题如下：

|          | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 读未提交 |  ✅   |     ✅      |  ✅   |
| 读已提交 |  ❎   |     ✅      |  ✅   |
| 可重复读 |  ❎   |     ❎      |  ✅   |
|  串行化  |  ❎   |     ❎      |  ❎   |





## 索引与 B+ 树

相关问题：

- B 树与 B+ 树的区别？
- 为什么数据库的索引要用 B+ 树，而不是 B 树？

先说什么是 B 树 ，由于其英文写为 B-Tree，所以也叫 B- 树。B 树其实就是 **多叉的二叉平衡树（或者叫平衡的多路搜索树）** ，如下图所示。

例子 1：最简单的 B 树，`n = 3`

<img src="https://gitee.com/sinkinben/pic-go/raw/master/img/20210310191741.png" style="width:50%;" />

例子 2: 基于 B 树的索引结构

<img src="https://gitee.com/sinkinben/pic-go/raw/master/img/20210310192538.png" style="width:80%;" />



B+树是基于 B 树的改进：

- 非叶子节点不保存数据，仅用作索引，叶子节点保存全部数据
- 所有叶子节点构成一个链表

例子 3 ：基于 B+ 树的索引结构

<img src="https://gitee.com/sinkinben/pic-go/raw/master/img/20210310192630.png" style="width:80%;" />

为什么数据库索引要用 B+ 树？

首先要知道：

- 局部性原理：当一个数据被用到时，其附近的数据通常也会被用到（与 Cache 局部性原理相同，包括空间局部性和时间局部性）。
- 磁盘预读：每次读取磁盘，OS 都会一次性读取若干个页面的大小到内核缓冲区中（也就是 APUE 所说的带缓冲的 I/O）。

使用 B+ 树的原因：

- B+ 树更有利于区间查找：SQL 当常出现 `where 1 <= key <= 10` 这样的查询，B+ 树在叶子结点可通过遍历链表的形式找到所需要的数据，而 B 树不能。
- B+ 树叶子节点构成链表，更利用范围查找和排序；而 B 树进行范围查找和排序则要对树进行递归遍历。
- B+ 树全节点遍历更快：所有叶子节点构成链表，全节点扫描，只需遍历这个链表即可。



## 索引的实现方式

有 3 种：B+ 树、哈希索引（aka，散列索引）、位图索引。



## 索引的类型

- 唯一索引 (Unique Index) ：索引的每一个索引值只对应唯一的数据记录；
- 主键索引 (Primary Key Index)：在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。
- 聚集索引 (Cluster Index)：通常用于**区间查询**的索引。

唯一索引和主键索引听起来很相似，其区别如下：

- 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
- 唯一性索引列允许空值，而主键列不允许为空值。
- 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。



## 数据库中的锁

首先看分类：

- 按锁的粒度划分：表级锁、行级锁、页级锁
- 按锁级别划分：共享锁、排它锁、意向锁
- 按加锁方式划分：自动锁、显示锁
- 按使用方式划分：乐观锁、悲观锁



**共享锁、排它锁、意向锁**

- 共享锁（读锁）：如果事务 T 对 A 加上共享锁，则其他事务只能对 A 再加共享锁，不能加其他锁。共享锁的事务只能读数据，不能写数据。
- 排它锁（写锁）：如果事务 T 对 A 加上排它锁，则其他事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。

为什么需要意向锁？

假设以下场景：事务 A 锁住了表中的一行，让这一行只能读，不能写；事务 B 申请整个表的写锁，如果事务 B 申请成功，那么理论上它就能修改表中的任意一行，这与 A 持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让 B 的申请被阻塞，直到 A 释放了行锁。

**如果没有意向锁，则需要遍历表中的每一行，判断是否存在某一行被排它锁锁住。**

如果有意向锁：

- 事务 A 必须先申请表的**意向共享锁（意向读锁）**，成功后再申请一行的行锁。
- 事务 B 申请申请表的写锁前，同样需要申请这个表的意向共享锁，但此时它已被 A 获取，因此 B 阻塞。

排它锁使用：

```sql
SELECT ... FOR UPDATE
```

共享锁使用：

```sql
SELECT ... LOCK IN SHARE MODE;
```



**行/页/表锁**

按锁的粒度从小到大为：

- 行锁
- 页锁
- 表锁

上面 3 种锁可细分为行读锁、行写锁等。



**乐观锁和悲观锁**

- 悲观锁：对数据的修改抱有悲观态度的并发控制方式。
  - 常见实现：修改某个数据前必须加一个写锁（就是平常理解的读写锁机制）。
  - 场景：读写次数大致相当的场景。
- 乐观锁：假设数据一般情况下不会造成冲突，在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
  - 常见实现：读数据不加任何锁，写数据按照业务需要判断是否加锁，冲突采用 2PC (Two Phase Commit) 的方式处理。
  - 场景：读远多于写的场景，比如一些图片存储服务。





## 三种 join

3 种 join 包括：join, left join, right join .

假设有 2 张表：

```text
+-------------+       +----------+
|   major     |       |   score  |
+---+---------+       +---+------+
| 1 | Chinese |       | 2 |  70  |
| 2 | Math    |       | 3 |  80  |
| 3 | English |       | 4 |  90  |
+---+---------+       +---+------+
```



**left join**

假设 `A left join B` ，那么 A 的字段全部保留，B 的字段可能出现 NULL 。

```sql
> select * from major left join score on major.id=score.id
+----+---------+------+-------+
| id | major   |  id  | score |
+----+---------+------+-------+
| 1  | Chinese | null | null  |
| 2  | Math    |  2   |  70   |
| 3  | English |  3   |  80   |
+----+---------+------+-------+
```

**right join**

与 left join 类似。

```sql
> select * from major right join score on major.id=score.id
+------+---------+------+-------+
| id   | major   |  id  | score |
+------+---------+------+-------+
| 2    | Chinese |  2   |  70   |
| 3    | Math    |  3   |  80   |
| null | null    |  4   |  90   |
+------+---------+------+-------+
```



**(inner) join**

其实就是 inner join，取交集，不会出现 null 的情况。

```sql
> select * from major join score on major.id=score.id
+------+---------+------+-------+
| id   | major   |  id  | score |
+------+---------+------+-------+
| 2    | Chinese |  2   |  70   |
| 3    | Math    |  3   |  80   |
+------+---------+------+-------+
```

